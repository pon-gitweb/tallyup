// @ts-nocheck
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import {
  View, Text, StyleSheet, FlatList, TouchableOpacity,
  RefreshControl, Alert, Modal, Pressable
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { getFirestore, collection, getDocs } from 'firebase/firestore';
import { useVenueId } from '../../context/VenueProvider';
import IdentityBadge from '../../components/IdentityBadge';

import { buildSuggestedOrdersInMemory } from '../../services/orders/suggest';
import {
  createDraftOrderWithLines,
  setSupplierSmart,
  setParSmart,
} from '../../services/orders';

type BucketRow = { id: string; supplierId: string; supplierName: string; itemsCount: number };
type SupplierPick = { id: string; name: string };

export default function SuggestedOrderScreen() {
  // Dev helpers
  // @ts-ignore
  (globalThis as any).__SO_PROBE__  = require('../../dev/soPermsProbe').probeSuggestedOrdersAccess;
  // @ts-ignore
  (globalThis as any).__SO_ATTACH__ = require('../../dev/attachVenue').attachUserToVenueIfAllowed;

  const nav = useNavigation<any>();
  const venueId = useVenueId();
  const db = getFirestore();

  const [rows, setRows] = useState<BucketRow[]>([]);
  const [refreshing, setRefreshing] = useState(false);

  // Unassigned review panel
  const [unassignedOpen, setUnassignedOpen] = useState(false);
  const [unassignedLines, setUnassignedLines] = useState<any[]>([]);

  // Supplier picker modal
  const [pickerOpen, setPickerOpen] = useState(false);
  const [pickerSuppliers, setPickerSuppliers] = useState<SupplierPick[]>([]);
  const [pickerForProductId, setPickerForProductId] = useState<string | null>(null);

  const loadSuppliers = useCallback(async (): Promise<SupplierPick[]> => {
    const snap = await getDocs(collection(db, 'venues', venueId, 'suppliers'));
    const out: SupplierPick[] = [];
    snap.forEach(d => out.push({ id: d.id, name: (d.data() as any)?.name || 'Supplier' }));
    // sort A→Z
    out.sort((a, b) => a.name.localeCompare(b.name));
    return out;
  }, [db, venueId]);

  const load = useCallback(async () => {
    if (!venueId) { setRows([]); return; }
    try {
      const compat = await buildSuggestedOrdersInMemory(venueId, { roundToPack: true, defaultParIfMissing: 6 });

      // names map
      const suppliersList = await loadSuppliers();
      const supplierNames: Record<string, string> = {};
      for (const s of suppliersList) supplierNames[s.id] = s.name;

      // unique buckets -> rows, filtering empty buckets (except unassigned if >0)
      const seen = new Set<any>();
      const tmp: BucketRow[] = [];
      for (const [key, bucket] of Object.entries(compat)) {
        if (seen.has(bucket)) continue;
        seen.add(bucket);
        const supplierId = key || 'unassigned';
        const itemsCount = bucket.lines?.length || 0;
        if (itemsCount <= 0) continue; // hide empties
        const supplierName =
          supplierId === 'unassigned' ? 'Unassigned' :
          supplierNames[supplierId] || 'Supplier';
        tmp.push({ id: supplierId, supplierId, supplierName, itemsCount });
      }
      // Promote Unassigned to top
      tmp.sort((a, b) => {
        if (a.id === 'unassigned' && b.id !== 'unassigned') return -1;
        if (b.id === 'unassigned' && a.id !== 'unassigned') return 1;
        return (b.itemsCount || 0) - (a.itemsCount || 0);
      });
      setRows(tmp);
    } catch (e:any) {
      if (__DEV__) console.log('[SuggestedOrders] load error', e?.code || e?.message || e);
      setRows([]);
    }
  }, [venueId, db, loadSuppliers]);

  useEffect(() => { load(); }, [load]);

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    await load();
    setRefreshing(false);
  }, [load]);

  // Sanitize suggested line -> draft order line (Firestore-safe, no undefined)
  const toDraftLine = (l: any) => {
    const name = (l.productName ?? String(l.productId ?? '')).trim() || 'Item';
    const qty = Number.isFinite(Number(l.qty)) ? Math.max(1, Number(l.qty)) : 1;
    const unitCost = Number.isFinite(Number(l.cost)) ? Number(l.cost) : 0;
    return {
      productId: String(l.productId),
      name,
      qty,
      unitCost,
    };
  };

  const createDraftForSupplier = useCallback(async (supplierId: string) => {
    if (!venueId) return;
    try {
      const compat = await buildSuggestedOrdersInMemory(venueId, { roundToPack: true, defaultParIfMissing: 6 });
      const bucket = compat[supplierId];
      if (!bucket || !bucket.lines?.length) {
        Alert.alert('Nothing to order', 'No suggested lines for this supplier.');
        return;
      }

      const linesSanitized = bucket.lines.map(toDraftLine);

      const res = await createDraftOrderWithLines(venueId, supplierId, linesSanitized);
      const orderId = (res && (res.id || res.orderId || res.docId)) || '';
      if (!orderId) {
        Alert.alert('Draft not created', 'Could not get a new draft order id.');
        return;
      }
      const supplierName = rows.find(r => r.supplierId === supplierId)?.supplierName || 'Supplier';
      nav.navigate('OrderEditor', { orderId, supplierName });
    } catch (e:any) {
      console.log('[SuggestedOrders] createDraftForSupplier error', e?.code || '', e?.message || e);
      Alert.alert('Could not create draft', e?.message || 'Please try again.');
    }
  }, [venueId, nav, rows]);

  const openSupplier = useCallback(async (supplierId: string) => {
    if (supplierId === 'unassigned') {
      const compat = await buildSuggestedOrdersInMemory(venueId, { roundToPack: true, defaultParIfMissing: 6 });
      const bucket = compat['unassigned'];
      const lines = bucket?.lines || [];
      setUnassignedLines(lines);
      setUnassignedOpen(true);
      return;
    }
    await createDraftForSupplier(supplierId);
  }, [venueId, createDraftForSupplier]);

  const createAllDrafts = useCallback(async () => {
    Alert.alert('Create Drafts', 'Create a draft per supplier (excluding Unassigned)?', [
      { text: 'Cancel', style: 'cancel' },
      { text: 'Create', style: 'default', onPress: async () => {
        for (const r of rows) {
          if (r.supplierId === 'unassigned') continue;
          await createDraftForSupplier(r.supplierId);
        }
      } }
    ]);
  }, [rows, createDraftForSupplier]);

  // ----- Unassigned: Supplier Picker -----
  const openSupplierPicker = useCallback(async (productId: string) => {
    try {
      const list = await loadSuppliers();
      if (!list.length) { Alert.alert('No suppliers', 'Create a supplier first.'); return; }
      setPickerSuppliers(list);
      setPickerForProductId(productId);
      setPickerOpen(true);
    } catch (e:any) {
      Alert.alert('Failed to load suppliers', e?.message || String(e));
    }
  }, [loadSuppliers]);

  const pickSupplier = useCallback(async (supplierId: string) => {
    if (!pickerForProductId) return;
    try {
      await setSupplierSmart(venueId, pickerForProductId, supplierId);
      setPickerOpen(false);
      setPickerForProductId(null);
      // Refresh lists
      await load();
      const compat = await buildSuggestedOrdersInMemory(venueId, { roundToPack: true, defaultParIfMissing: 6 });
      setUnassignedLines(compat['unassigned']?.lines || []);
    } catch (e:any) {
      Alert.alert('Failed to assign supplier', e?.message || String(e));
    }
  }, [venueId, pickerForProductId, load]);

  const setParPack = useCallback(async (productId: string, suggestedPack?: number) => {
    try {
      await setParSmart(venueId, productId, suggestedPack || 6);
      Alert.alert('PAR updated', `PAR set to ${suggestedPack || 6}`);
      await load();
      const compat = await buildSuggestedOrdersInMemory(venueId, { roundToPack: true, defaultParIfMissing: 6 });
      setUnassignedLines(compat['unassigned']?.lines || []);
    } catch (e:any) {
      Alert.alert('Failed to set PAR', e?.message || 'Try again.');
    }
  }, [venueId, load]);

  const Item = ({ item }: { item: BucketRow }) => (
    <TouchableOpacity style={S.row} onPress={() => openSupplier(item.supplierId)}>
      <View style={{ flex: 1 }}>
        <Text style={S.rowTitle}>{item.supplierName}</Text>
        <Text style={S.rowSub}>{item.itemsCount || 0} items</Text>
      </View>
      <Text style={S.chev}>›</Text>
    </TouchableOpacity>
  );

  return (
    <View style={S.wrap}>
      <View style={S.headerRow}>
        <Text style={S.title}>Suggested Orders</Text>
        <IdentityBadge />
      </View>

      <TouchableOpacity style={S.primary} onPress={createAllDrafts}>
        <Text style={S.primaryText}>Create Drafts (All)</Text>
      </TouchableOpacity>

      {!unassignedOpen && (
        <FlatList
          data={rows}
          keyExtractor={(it) => String(it.id)}
          renderItem={Item}
          refreshControl={<RefreshControl refreshing={refreshing} onRefresh={onRefresh} />}
          ListEmptyComponent={
            <View style={S.empty}>
              <Text style={S.emptyTitle}>No suggestions yet</Text>
              <Text style={S.emptyText}>
                Complete a stock take and set PAR or pack sizes. Items without suppliers will appear under “Unassigned”.
              </Text>
            </View>
          }
        />
      )}

      {unassignedOpen && (
        <View style={S.panel}>
          <View style={S.panelHead}>
            <Text style={S.panelTitle}>Unassigned ({unassignedLines.length})</Text>
            <TouchableOpacity onPress={() => setUnassignedOpen(false)}>
              <Text style={S.link}>Close</Text>
            </TouchableOpacity>
          </View>

          {unassignedLines.length === 0 ? (
            <Text style={S.rowSub}>All set — no unassigned items.</Text>
          ) : (
            <FlatList
              data={unassignedLines}
              keyExtractor={(l) => l.productId}
              renderItem={({ item: l }) => (
                <View style={S.lineRow}>
                  <View style={{ flex: 1 }}>
                    <Text style={S.lineName}>{l.productName || l.productId}</Text>
                    <Text style={S.rowSub}>Qty {l.qty} · ${Number(l.cost || 0).toFixed(2)}</Text>
                  </View>
                  <TouchableOpacity style={S.smallBtn} onPress={() => openSupplierPicker(l.productId)}>
                    <Text style={S.smallBtnText}>Assign</Text>
                  </TouchableOpacity>
                  <TouchableOpacity style={[S.smallBtn, { marginLeft: 8 }]} onPress={() => setParPack(l.productId)}>
                    <Text style={S.smallBtnText}>Set PAR</Text>
                  </TouchableOpacity>
                </View>
              )}
            />
          )}
        </View>
      )}

      {/* Supplier Picker Modal */}
      <Modal visible={pickerOpen} transparent animationType="fade" onRequestClose={() => setPickerOpen(false)}>
        <Pressable style={S.modalBack} onPress={() => setPickerOpen(false)}>
          <View style={S.modalCard}>
            <Text style={S.modalTitle}>Choose Supplier</Text>
            <FlatList
              data={pickerSuppliers}
              keyExtractor={(s) => s.id}
              renderItem={({ item }) => (
                <TouchableOpacity style={S.modalRow} onPress={() => pickSupplier(item.id)}>
                  <Text style={S.modalRowText}>{item.name}</Text>
                </TouchableOpacity>
              )}
              ListEmptyComponent={<Text style={S.rowSub}>No suppliers found.</Text>}
            />
            <TouchableOpacity style={[S.smallBtn, { alignSelf: 'flex-end', marginTop: 8 }]} onPress={() => setPickerOpen(false)}>
              <Text style={S.smallBtnText}>Cancel</Text>
            </TouchableOpacity>
          </View>
        </Pressable>
      </Modal>
    </View>
  );
}

const S = StyleSheet.create({
  wrap: { flex: 1, padding: 16 },
  headerRow: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 12 },
  title: { fontSize: 20, fontWeight: '600' },
  primary: { backgroundColor: '#2563eb', paddingVertical: 10, paddingHorizontal: 14, borderRadius: 8, alignSelf: 'flex-start', marginBottom: 8 },
  primaryText: { color: '#fff', fontWeight: '600' },
  row: { flexDirection: 'row', alignItems: 'center', paddingVertical: 14, borderBottomWidth: StyleSheet.hairlineWidth, borderColor: '#e5e7eb' },
  rowTitle: { fontSize: 16, fontWeight: '600' },
  rowSub: { fontSize: 12, color: '#6b7280' },
  chev: { fontSize: 24, color: '#9ca3af', marginLeft: 8 },
  empty: { paddingTop: 48, paddingHorizontal: 8 },
  emptyTitle: { fontSize: 16, fontWeight: '600', marginBottom: 8 },
  emptyText: { fontSize: 13, color: '#6b7280' },
  panel: { marginTop: 8, borderWidth: StyleSheet.hairlineWidth, borderColor: '#e5e7eb', borderRadius: 10, padding: 12 },
  panelHead: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 8 },
  panelTitle: { fontSize: 16, fontWeight: '600' },
  link: { color: '#2563eb', fontWeight: '600' },
  lineRow: { flexDirection: 'row', alignItems: 'center', paddingVertical: 10, borderBottomWidth: StyleSheet.hairlineWidth, borderColor: '#eee' },
  lineName: { fontSize: 14, fontWeight: '600' },
  smallBtn: { backgroundColor: '#111827', paddingVertical: 6, paddingHorizontal: 10, borderRadius: 8 },
  smallBtnText: { color: '#fff', fontSize: 12, fontWeight: '600' },
  modalBack: { flex: 1, backgroundColor: 'rgba(0,0,0,0.3)', justifyContent: 'center', padding: 24 },
  modalCard: { backgroundColor: '#fff', borderRadius: 12, padding: 16, maxHeight: '70%' },
  modalTitle: { fontSize: 18, fontWeight: '700', marginBottom: 8 },
  modalRow: { paddingVertical: 12, borderBottomWidth: StyleSheet.hairlineWidth, borderColor: '#eee' },
  modalRowText: { fontSize: 16 },
});
