// @ts-nocheck
import React, { useEffect, useMemo, useState, useCallback, useRef } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, Alert, ActivityIndicator, ScrollView, Modal } from 'react-native';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { useVenueId } from '../../context/VenueProvider';
import { getFirestore, doc, getDoc, collection, getDocs } from 'firebase/firestore';
import * as DocumentPicker from 'expo-document-picker';
import * as FileSystem from 'expo-file-system';

import ReceiveOptionsModal from './receive/ReceiveOptionsModal';
import ManualReceiveScreen from './receive/ManualReceiveScreen';
import { uploadCsvTextToStorage } from '../../services/uploads/uploadCsvTextToStorage';

import { finalizeReceiveFromCsv } from '../../services/orders/receive';

import { processInvoicesPdf } from '../../services/invoices/processInvoicesPdf';

export default function OrderDetailScreen() {

type Params = { orderId: string };
type Line = { id: string; productId?: string; name?: string; qty?: number; unitCost?: number };

/** Confidence tier helper */
function tierForConfidence(c?: number): 'low'|'medium'|'high' {
  const x = Number.isFinite(c as any) ? Number(c) : -1;
  if (x >= 0.95) return 'high';
  if (x >= 0.80) return 'medium';
  return 'low';
}

  const nav = useNavigation<any>();
  const route = useRoute<RouteProp<Record<string, Params>, string>>();
  const venueId = useVenueId();
  const orderId = (route.params as any)?.orderId as string;

  const [orderMeta, setOrderMeta] = useState<any>(null);
  const [lines, setLines] = useState<Line[]>([]);
  const [loading, setLoading] = useState(true);

  // Receive modals
  const [receiveOpen, setReceiveOpen] = useState(false);
  const [manualOpen, setManualOpen] = useState(false);

  const [csvReview, setCsvReview] = useState<null | {
    storagePath: string;
    confidence?: number;
    warnings?: string[];
    lines: Array<{ productId?: string; code?: string; name: string; qty: number; unitPrice?: number }>;
    invoice: any;
    matchReport?: any;
  }>(null);

  const [pdfReview, setPdfReview] = useState<null | {
    storagePath: string;
    confidence?: number;
    warnings?: string[];
    lines: Array<{ name: string; qty: number; unitPrice?: number; code?: string }>;
    invoice: any;
    matchReport?: any;
  }>(null);

  // prevent duplicate auto-confirms
  const autoConfirmedRef = useRef(false);

  const db = getFirestore();

  useEffect(()=>{
    let alive = true;
    (async ()=>{
      try{
        if (!venueId || !orderId) return;
        const oSnap = await getDoc(doc(db, 'venues', venueId, 'orders', orderId));
        const oVal:any = oSnap.exists() ? oSnap.data() : {};
        if (!alive) return;
        setOrderMeta({ id: oSnap.id, ...oVal });

        const linesSnap = await getDocs(collection(db, 'venues', venueId, 'orders', orderId, 'lines'));
        const linesData:Line[] = [];
        linesSnap.forEach((docSnap)=>{
          const d:any = docSnap.data()||{};
          linesData.push({
            id: docSnap.id,
            productId: d.productId,
            name: d.name,
            qty: Number.isFinite(d.qty) ? Number(d.qty) : (d.qty||0),
            unitCost: Number.isFinite(d.unitCost) ? Number(d.unitCost) : (d.unitCost||0),
          });
        });
        setLines(linesData);
      }catch(e){
        console.warn('[OrderDetail] load fail', e);
      }finally{
        if (alive) setLoading(false);
      }
    })();
    return ()=>{ alive=false; };
  },[db,venueId,orderId]);

  /** CSV picker + upload + parse + PO pre-check */
  const pickCsvAndProcess = useCallback(async ()=>{
    try{
      const res = await DocumentPicker.getDocumentAsync({ type: 'text/csv' });
      if (res.canceled || !res.assets?.[0]) return;

      const asset = res.assets[0];
      const contents = await FileSystem.readAsStringAsync(asset.uri);

      const { storagePath } = await uploadCsvTextToStorage(venueId, orderId, contents);
      const review = await uploadInvoiceCsv(venueId, orderId);

      const orderPo = String(orderMeta?.poNumber ?? '').trim();
      const parsedPo = String(review?.invoice?.poNumber ?? '').trim();
      if (orderPo && parsedPo && orderPo !== parsedPo) {
        Alert.alert(
          'PO mismatch',
          `Invoice PO (${parsedPo || '—'}) does not match order PO (${orderPo}).\nUse Manual Receive to proceed.`,
          [
            { text: 'Cancel', style: 'cancel' },
            { text: 'Manual Receive', onPress: ()=> setManualOpen(true) },
          ]
        );
        return;
      }

      setCsvReview({ ...review, storagePath });
    }catch(e:any){
      console.error('[OrderDetail] csv pick/process fail', e);
      Alert.alert('Upload failed', String(e?.message || e));
    }
  },[venueId,orderId,orderMeta]);

  /** PDF picker + upload + parse + PO pre-check */
  const pickPdfAndUpload = useCallback(async ()=>{
    try{
      const res = await DocumentPicker.getDocumentAsync({
        type: 'application/pdf',
        multiple: false,
        copyToCacheDirectory: true,
      });
      if (res.canceled || !res.assets?.[0]) return;

      const asset = res.assets[0];
      const { fullPath } = await uploadFileAsBase64({ venueId, orderId, fileUri: (a && (a.uri || a.fileUri)) || '', fileName: (a && (a.name || a.fileName)) || 'invoice_upload' });

      const parsed = await processInvoicesPdf({ venueId, orderId, storagePath: fullPath });

      const orderPo = String(orderMeta?.poNumber ?? '').trim();
      const parsedPo = String(parsed?.invoice?.poNumber ?? '').trim();

      if (orderPo && parsedPo && orderPo !== parsedPo) {
        Alert.alert(
          'PO mismatch',
          `Invoice PO (${parsedPo || '—'}) does not match order PO (${orderPo}).\nUse Manual Receive to proceed.`,
          [
            { text: 'Cancel', style: 'cancel' },
            { text: 'Manual Receive', onPress: ()=> setManualOpen(true) },
          ]
        );
        return;
      }

      setPdfReview({ ...parsed, storagePath: fullPath });
      setReceiveOpen(false);

      if (__DEV__) console.log('[OrderDetail] PDF parsed and staged', { lines: parsed?.lines?.length ?? 0, po: parsedPo || null });
    }catch(e:any){
      if (__DEV__) console.log('[OrderDetail] pdf upload/parse fail', e);
      Alert.alert('Upload failed', String(e?.message || e));
    }
  },[venueId,orderId,orderMeta]);

  /** NEW: Unified file picker that routes to PDF/CSV flows */
  const pickFileAndRoute = useCallback(async ()=>{
    try {
      const res = await DocumentPicker.getDocumentAsync({
        type: ['application/pdf','text/csv','text/comma-separated-values','text/plain'],
        multiple: false, copyToCacheDirectory: true,
      });
      if (res.canceled || !res.assets?.[0]) return;
      const a = res.assets[0];
      const name = (a.name||'').toLowerCase();
      const mime = (a.mimeType||'').toLowerCase();
      const isPdf = mime.includes('pdf') || name.endsWith('.pdf');
      const isCsv = mime.includes('csv') || name.endsWith('.csv') || name.endsWith('.txt');

      if (isPdf) {
        const { fullPath } = await uploadFileAsBase64({ venueId, orderId, fileUri: (a && (a.uri || a.fileUri)) || '', fileName: (a && (a.name || a.fileName)) || 'invoice_upload' });
        const parsed = await processInvoicesPdf({ venueId, orderId, storagePath: fullPath });
        const orderPo = String(orderMeta?.poNumber ?? '').trim();
        const parsedPo = String(parsed?.invoice?.poNumber ?? '').trim();
        if (orderPo && parsedPo && orderPo !== parsedPo) {
          Alert.alert('PO mismatch', `Invoice PO (${parsedPo || '—'}) does not match order PO (${orderPo}).\nUse Manual Receive to proceed.`,
            [{ text:'Cancel', style:'cancel' }, { text:'Manual Receive', onPress:()=>setManualOpen(true) }]);
          return;
        }
        setPdfReview({ ...parsed, storagePath: fullPath });
        setReceiveOpen(false);
        return;
      }

      if (isCsv) {
        const contents = await FileSystem.readAsStringAsync(a.uri);
        const { storagePath } = await uploadCsvTextToStorage(venueId, orderId, contents);
        const review = await uploadInvoiceCsv(venueId, orderId);
        const orderPo = String(orderMeta?.poNumber ?? '').trim();
        const parsedPo = String(review?.invoice?.poNumber ?? '').trim();
        if (orderPo && parsedPo && orderPo !== parsedPo) {
          Alert.alert('PO mismatch', `Invoice PO (${parsedPo || '—'}) does not match order PO (${orderPo}).\nUse Manual Receive to proceed.`,
            [{ text:'Cancel', style:'cancel' }, { text:'Manual Receive', onPress:()=>setManualOpen(true) }]);
          return;
        }
        setCsvReview({ ...review, storagePath });
        setReceiveOpen(false);
        return;
      }

      Alert.alert('Unsupported file', 'Please choose a PDF or CSV invoice.');
    } catch (e:any) {
      Alert.alert('Upload failed', String(e?.message || e));
    }
  },[venueId, orderId, orderMeta]);

  /** Confidence banner */
  const ConfidenceBanner = ({ kind, score }:{ kind:'csv'|'pdf'; score?:number })=>{
    const t = tierForConfidence(score);
    const msg =
      t==='low'    ? 'Low confidence: results may be inaccurate. Consider Manual Receive.'
    : t==='medium' ? 'Medium confidence: please review carefully before confirming.'
    :                 'High confidence: looks good.';
    const bg =
      t==='low'    ? '#FEF3C7'
    : t==='medium' ? '#E0E7FF'
    :                 '#DCFCE7';
    const fg =
      t==='low'    ? '#92400E'
    : t==='medium' ? '#1E3A8A'
    :                 '#065F46';

    if (__DEV__) console.log('[Receive][confidence]', { kind, score, tier: t });

    return (
      <View style={{backgroundColor:bg, padding:10, borderRadius:8, marginBottom:10}}>
        <Text style={{color:fg, fontWeight:'700'}}>{msg} {Number.isFinite(score)? `(confidence ${(score!*100).toFixed(0)}%)`:''}</Text>
        {t==='low' ? (
          <TouchableOpacity onPress={()=>setManualOpen(true)} style={{marginTop:8, alignSelf:'flex-start', backgroundColor:'#111', paddingVertical:8, paddingHorizontal:12, borderRadius:8}}>
            <Text style={{color:'#fff', fontWeight:'700'}}>Open Manual Receive</Text>
          </TouchableOpacity>
        ) : null}
      </View>
    );
  };

  /** Auto-confirm CSV on high confidence (≥0.95) once */
  useEffect(()=>{
    if (!csvReview || autoConfirmedRef.current) return;
    const t = tierForConfidence(csvReview.confidence);
    if (t === 'high') {
      autoConfirmedRef.current = true;
      (async ()=>{
        try{
          await finalizeReceiveFromCsv({
            venueId,
            orderId,
            parsed: {
              invoice: csvReview.invoice,
              lines: csvReview.lines,
              matchReport: csvReview.matchReport,
              confidence: csvReview.confidence,
              warnings: csvReview.warnings
            }
          });
          Alert.alert('Received', 'High-confidence invoice auto-accepted and posted.');
          setReceiveOpen(false);
          setCsvReview(null);
          nav.goBack();
        }catch(e:any){
          autoConfirmedRef.current = false;
          Alert.alert('Auto-receive failed', String(e?.message || e));
        }
      })();
    }
  },[csvReview, venueId, orderId, nav]);

  const totalOrdered = useMemo(()=>{
    return lines.reduce((sum,line)=>{
      const cost = line.unitCost||0;
      const qty = line.qty||0;
      return sum + (cost * qty);
    },0);
  },[lines]);

  const csvWarnings = useMemo(() => {
    if (!csvReview) return [];
    return (csvReview.warnings || csvReview.matchReport?.warnings || []);
  }, [csvReview]);

  const pdfWarnings = useMemo(() => {
    if (!pdfReview) return [];
    return (pdfReview.warnings || pdfReview.matchReport?.warnings || []);
  }, [pdfReview]);

  if (loading) return <View style={S.loading}><ActivityIndicator/></View>;

  return (
    <View style={S.wrap}>
      <View style={S.top}>
        <View>
          <Text style={S.title}>{orderMeta?.supplierName || 'Order'}</Text>
        <Text style={S.meta}>
            {orderMeta?.status ? `Status: ${orderMeta.status}` : ''}{orderMeta?.poNumber ? ` • PO: ${orderMeta.poNumber}` : ''}
          </Text>
        </View>
        {String(orderMeta?.status).toLowerCase()==='submitted' ? (
          <TouchableOpacity style={[S.receiveBtn, { position: 'absolute', right: 16, bottom: 16, zIndex: 10, elevation: 6, shadowColor: '#000', shadowOpacity: 0.2, shadowOffset: { width: 0, height: 2 }, shadowRadius: 4 }]} onPress={()=>setReceiveOpen(true)}>
            <Text style={S.receiveBtnText}>Receive</Text>
          </TouchableOpacity>
        ) : null}
      </View>

      {csvReview ? (
        <ScrollView style={{flex:1}}>
          <View style={{padding:16}}>
            <ConfidenceBanner kind="csv" score={csvReview.confidence} />
            <Text style={{fontSize:16,fontWeight:'800',marginBottom:8}}>Review Invoice (CSV)</Text>
            {csvWarnings.length > 0 ? (
              <View style={{marginBottom:8}}>
                {csvWarnings.map((w,idx)=>(<Text key={idx} style={{color:'#92400E'}}>• {w}</Text>))}
              </View>
            ) : null}
            {(csvReview.lines||[]).slice(0,40).map((pl,idx)=>(
              <View key={idx} style={{paddingVertical:6,borderBottomWidth:StyleSheet.hairlineWidth,borderColor:'#E5E7EB'}}>
                <Text style={{fontWeight:'700'}}>{pl.name || pl.code || '(line)'}</Text>
                <Text style={{color:'#6B7280'}}>Qty: {pl.qty} • Unit: ${pl.unitPrice?.toFixed(2)||'0.00'}</Text>
              </View>
            ))}
            {(csvReview.lines||[]).length>40 ? <Text style={{marginTop:8,color:'#6B7280'}}>... and {csvReview.lines.length-40} more lines</Text> : null}

            <View style={{flexDirection:'row',gap:12,marginTop:16}}>
              <TouchableOpacity style={{flex:1,paddingVertical:12,backgroundColor:'#F3F4F6',borderRadius:8}} onPress={()=>setCsvReview(null)}>
                <Text style={{textAlign:'center',fontWeight:'700',color:'#374151'}}>Cancel</Text>
              </TouchableOpacity>
              <TouchableOpacity style={{flex:1,paddingVertical:12,backgroundColor:'#111827',borderRadius:8}} onPress={async ()=>{
                autoConfirmedRef.current = true;
                try{
                  await finalizeReceiveFromCsv({
                    venueId,
                    orderId,
                    parsed: {
                      invoice: csvReview.invoice,
                      lines: csvReview.lines,
                      matchReport: csvReview.matchReport,
                      confidence: csvReview.confidence,
                      warnings: csvReview.warnings
                    }
                  });
                  Alert.alert('Received', 'Invoice posted and order marked received.');
                  setReceiveOpen(false);
                  setCsvReview(null);
                  nav.goBack();
                }catch(e:any){
                  autoConfirmedRef.current = false;
                  Alert.alert('Receive failed', String(e?.message || e));
                }
              }}>
                <Text style={{textAlign:'center',fontWeight:'700',color:'#fff'}}>Confirm Receive</Text>
              </TouchableOpacity>
            </View>
          </View>
        </ScrollView>
      ) : pdfReview ? (
        <ScrollView style={{flex:1}}>
          <View style={{padding:16}}>
            <ConfidenceBanner kind="pdf" score={pdfReview.confidence} />
            <Text style={{fontSize:16,fontWeight:'800',marginBottom:8}}>Review Invoice (PDF)</Text>
            {pdfWarnings.length > 0 ? (
              <View style={{marginBottom:8}}>
                {pdfWarnings.map((w,idx)=>(<Text key={idx} style={{color:'#92400E'}}>• {w}</Text>))}
              </View>
            ) : null}
            {(pdfReview.lines||[]).slice(0,40).map((pl,idx)=>(
              <View key={idx} style={{paddingVertical:6,borderBottomWidth:StyleSheet.hairlineWidth,borderColor:'#E5E7EB'}}>
                <Text style={{fontWeight:'700'}}>{pl.name || pl.code || '(line)'}</Text>
                <Text style={{color:'#6B7280'}}>Qty: {pl.qty} • Unit: ${pl.unitPrice?.toFixed(2)||'0.00'}</Text>
              </View>
            ))}
            {(pdfReview.lines||[]).length>40 ? <Text style={{marginTop:8,color:'#6B7280'}}>... and {pdfReview.lines.length-40} more lines</Text> : null}

            <View style={{flexDirection:'row',gap:12,marginTop:16}}>
              <TouchableOpacity style={{flex:1,paddingVertical:12,backgroundColor:'#F3F4F6',borderRadius:8}} onPress={()=>setPdfReview(null)}>
                <Text style={{textAlign:'center',fontWeight:'700',color:'#374151'}}>Close</Text>
              </TouchableOpacity>
            </View>
          </View>
        </ScrollView>
      ) : (
        lines.length>0 && (
          <FlatList
            data={lines}
            keyExtractor={(x)=>x.id}
            renderItem={({item})=>(
              <View style={{paddingHorizontal:16,paddingVertical:12,borderBottomWidth:StyleSheet.hairlineWidth,borderColor:'#E5E7EB'}}>
                <Text style={{fontWeight:'700'}}>{item.name||item.productId||'Line'}</Text>
                <Text style={{color:'#6B7280',marginTop:4}}>
                  Qty: {item.qty||0} • Unit: ${(item.unitCost||0).toFixed(2)} • Line: ${((item.unitCost||0)*(item.qty||0)).toFixed(2)}
                </Text>
              </View>
            )}
            ListFooterComponent={
              <View style={{padding:16,borderTopWidth:StyleSheet.hairlineWidth,borderColor:'#E5E7EB'}}>
                <Text style={{fontWeight:'800'}}>Totals</Text>
                <Text style={{color:'#6B7280',marginTop:4}}>Ordered: ${totalOrdered.toFixed(2)}</Text>
              </View>
            }
          />
        )
      )}

      {/* Receive options sheet */}
      <ReceiveOptionsModal
        visible={receiveOpen}
        onClose={()=>setReceiveOpen(false)}
        onCsvSelected={pickCsvAndProcess}
        onManualSelected={()=>setManualOpen(true)}
        orderId={orderId}
        orderLines={lines}
        onPdfSelected={pickPdfAndUpload}
        onFileSelected={pickFileAndRoute}
      />

      {/* Manual receive modal (inline; no nav changes) */}
      <Modal visible={manualOpen} transparent animationType="slide" onRequestClose={()=>setManualOpen(false)}>
        <View style={{flex:1, backgroundColor:'rgba(0,0,0,0.35)', justifyContent:'flex-end'}}>
          <View style={{maxHeight:'85%', backgroundColor:'#fff', borderTopLeftRadius:16, borderTopRightRadius:16, padding:16}}>
            <ManualReceiveScreen
              venueId={venueId}
              orderId={orderId}
              orderLines={lines.map(l => ({ id: l.id, productId: l.productId, name: l.name, orderedQty: l.qty }))}
              onDone={()=>{
                setManualOpen(false);
                Alert.alert('Received', 'Manual receive saved.');
                nav.goBack();
              }}
              embed
            />
            <TouchableOpacity onPress={()=>setManualOpen(false)} style={{alignSelf:'center', marginTop:8, padding:8}}>
              <Text style={{fontWeight:'700'}}>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const S = StyleSheet.create({
  wrap:{flex:1,backgroundColor:'#fff'},
  top:{padding:16,flexDirection:'row',alignItems:'center',justifyContent:'space-between',borderBottomWidth:StyleSheet.hairlineWidth,borderColor:'#E5E7EB'},
  title:{fontSize:18,fontWeight:'800'},
  meta:{color:'#6B7280',marginTop:2},
  receiveBtn:{backgroundColor:'#111827',paddingVertical:10,paddingHorizontal:16,borderRadius:8},
  receiveBtnText:{color:'#fff',fontWeight:'800'},
  loading:{flex:1,justifyContent:'center',alignItems:'center'},
});
