const functions = require("firebase-functions");
const express = require("express");
const cors = require("cors");
const admin = require("firebase-admin");

try { admin.app(); } catch { admin.initializeApp(); }

const app = express();
app.use(cors({ origin: true }));
app.use(express.json({ limit: "15mb" })); // allow base64 payloads

// ---- existing endpoints you already had (kept) ----
app.get("/api/entitlement", (req, res) => {
  res.setHeader("x-ai-remaining", "99");
  res.setHeader("x-ai-retry-after", "0");
  return res.json({ ok: true, entitled: true });
});

app.post("/api/entitlement/dev-grant", (req, res) => {
  res.setHeader("x-ai-remaining", "99");
  res.setHeader("x-ai-retry-after", "0");
  return res.json({ ok: true, granted: true });
});

app.post("/api/validate-promo", (req, res) => {
  res.setHeader("x-ai-remaining", "99");
  res.setHeader("x-ai-retry-after", "0");
  return res.json({ ok: true, valid: true, quota: 99 });
});

app.post("/api/suggest-orders", (req, res) => {
  try {
    const body = req.body || {};
    const { venueId, baseline } = body;
    if (!venueId || !baseline) return res.status(400).json({ error: "missing venueId/baseline" });
    const aiRemaining = Number.isFinite(Number(req.headers["x-ai-remaining"])) ? Number(req.headers["x-ai-remaining"]) : 99;
    res.setHeader("x-ai-remaining", String(aiRemaining));
    res.setHeader("x-ai-retry-after", "0");
    return res.json({
      buckets: baseline.buckets || {},
      unassigned: baseline.unassigned || { lines: [] },
      meta: { rationale:"overlay_passthrough", factors:["Server reachable","LLM not yet applied"], aiRemaining, retryAfterSeconds:0 }
    });
  } catch (e) {
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

app.post("/api/variance-explain", (req, res) => {
  try {
    const b = req.body || {};
    const rv = Number(b.recentSoldQty ?? NaN);
    const rr = Number(b.recentReceivedQty ?? NaN);
    const factors = [];
    const missing = [];
    if (!b.itemName) missing.push("itemName");
    if (!("varianceQty" in b)) missing.push("varianceQty");
    if (Number.isFinite(rv) && Math.abs(rv) > 0) factors.push(`Recent sales ${rv > 0 ? "increase":"decline"} (${rv})`);
    if (Number.isFinite(rr) && Math.abs(rr) > 0) factors.push(`Recent delivery impact (${rr})`);
    if (b.lastDeliveryAt) factors.push(`Last delivery at ${b.lastDeliveryAt}`);
    if (b.par != null) factors.push(`PAR set to ${b.par}`);
    const confidence = 0.7;
    const aiRemaining = 99;
    res.setHeader("x-ai-remaining", String(aiRemaining));
    res.setHeader("x-ai-retry-after", "0");
    return res.json({ summary:"Variance likely due to normal count fluctuations.", factors, missing, confidence, meta:{ aiRemaining, retryAfterSeconds:0 }});
  } catch (e) {
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

// ---- NEW: server-side file upload (no client Blob) ----
/**
 * POST /api/upload-file
 * body: { destPath: string, dataUrl: string, cacheControl?: string }
 * - dataUrl is a "data:<mime>;base64,<...>" string (we accept text/csv or application/pdf)
 * - writes to default GCS bucket using Admin SDK
 */
app.post("/api/upload-file", async (req, res) => {
  try {
    const { destPath, dataUrl, cacheControl } = req.body || {};
    if (!destPath || !dataUrl) return res.status(400).json({ ok:false, error:"missing destPath/dataUrl" });

    const m = String(dataUrl).match(/^data:([^;]+);base64,(.*)$/);
    if (!m) return res.status(400).json({ ok:false, error:"invalid dataUrl" });
    const contentType = m[1];
    const b64 = m[2];

    const buf = Buffer.from(b64, "base64");
    const bucket = admin.storage().bucket();
    const file = bucket.file(destPath);
    await file.save(buf, {
      metadata: { contentType, cacheControl: cacheControl || "public,max-age=3600" },
      resumable: false
    });
    const [downloadURL] = await file.getSignedUrl({ action:"read", expires: Date.now() + 3600*1000 });

    return res.json({ ok:true, fullPath: destPath, downloadURL });
  } catch (e) {
    console.error("[upload-file] error", e);
    return res.status(500).json({ ok:false, error: String(e?.message || e) });
  }
});

// ---- Optional: CSV normalizer kept here if you need it later ----
app.post("/api/process-invoices-csv", async (req, res) => {
  try {
    const { venueId, orderId, storagePath } = req.body || {};
    if (!venueId || !orderId || !storagePath) {
      return res.status(400).json({ ok:false, error:"missing venueId/orderId/storagePath" });
    }
    // You can read & parse from bucket if needed; omitted for brevity
    return res.json({ ok:true, venueId, orderId, storagePath, parsed:false });
  } catch (e) {
    return res.status(500).json({ ok:false, error: String(e?.message || e) });
  }
});

exports.api = functions.region("us-central1").https.onRequest(app);
