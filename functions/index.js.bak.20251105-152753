/**
 * Stable Cloud Functions entry with Express (region us-central1).
 * Routes:
 *   - GET  /api/entitlement
 *   - POST /api/validate-promo
 *   - POST /api/suggest-orders
 *   - POST /api/upload-file
 *   - POST /api/process-invoices-csv
 *   - POST /api/process-invoices-pdf
 *   - POST /api/reconcile-invoice     <-- NEW
 */
const functions = require('firebase-functions');
const express = require('express');
const cors = require('cors');
const admin = require('firebase-admin');
const { parse: csvParseSync } = require('csv-parse/sync');

try { admin.app(); } catch { admin.initializeApp(); }

const app = express();
app.use(cors({ origin: true }));
app.use(express.json({ limit: '15mb' }));

// ---------------------- Entitlement (kept) ----------------------
app.get('/api/entitlement', (req, res) => {
  res.setHeader('x-ai-remaining', '99');
  res.setHeader('x-ai-retry-after', '0');
  return res.json({ ok: true, entitled: true });
});
app.post('/api/validate-promo', (req, res) => {
  res.setHeader('x-ai-remaining', '99');
  res.setHeader('x-ai-retry-after', '0');
  return res.json({ ok: true, valid: true, quota: 99 });
});

// ----------------- Suggest orders passthrough (kept) ------------
app.post('/api/suggest-orders', (req, res) => {
  try {
    const body = req.body || {};
    const { venueId, baseline } = body;
    if (!venueId || !baseline) return res.status(400).json({ error: 'missing venueId/baseline' });
    const aiRemaining = Number.isFinite(Number(req.headers['x-ai-remaining'])) ? Number(req.headers['x-ai-remaining']) : 99;
    res.setHeader('x-ai-remaining', String(aiRemaining));
    res.setHeader('x-ai-retry-after', '0');
    return res.json({
      buckets: baseline.buckets || {},
      unassigned: baseline.unassigned || { lines: [] },
      meta: { rationale: 'overlay_passthrough', factors: ['Server reachable','LLM not yet applied'], aiRemaining, retryAfterSeconds: 0 }
    });
  } catch (e) {
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

// ---------------------- Upload CSV/PDF to GCS -------------------
app.post(['/upload-file','/api/upload-file'], async (req, res) => {
  try {
    const { destPath, dataUrl, cacheControl } = req.body || {};
    if (!destPath || !dataUrl) return res.status(400).json({ ok:false, error:'destPath and dataUrl required' });

    const m = String(dataUrl).match(/^data:([^;]+);base64,(.+)$/);
    if (!m) return res.status(400).json({ ok:false, error:'Invalid dataUrl' });

    const contentType = m[1];
    const base64 = m[2];
    const buffer = Buffer.from(base64, 'base64');

    const bucket = admin.storage().bucket();
    const file = bucket.file(destPath);

    await file.save(buffer, {
      resumable: false,
      contentType,
      metadata: { contentType, cacheControl: cacheControl || 'public,max-age=3600' },
    });

    return res.json({ ok: true, fullPath: destPath });
  } catch (e) {
    console.error('[upload-file] error', e);
    return res.status(500).json({ ok:false, error: String(e?.message || e) });
  }
});

// ------------------------- PDF processor ------------------------
function extractPdfLines(text) {
  // Very basic heuristic extractor: "name ... qty x price"
  // You can refine this later per supplier template.
  const lines = [];
  const warnings = [];
  const rows = String(text || '').split(/\n+/);
  for (const row of rows) {
    const s = row.trim();
    if (!s) continue;
    // try to find quantity and price at the end
    const m = s.match(/(.+?)\s+(\d+(?:\.\d+)?)\s+[xX*]\s*\$?(\d+(?:\.\d+)?)/);
    if (m) {
      const name = m[1].trim();
      const qty = Number(m[2]);
      const unitPrice = Number(m[3]);
      if (name && Number.isFinite(qty) && Number.isFinite(unitPrice)) {
        lines.push({ name, qty, unitPrice });
      }
    }
  }
  if (!lines.length) warnings.push('No obvious line items detected in PDF text.');
  return { lines, warnings };
}

app.post('/api/process-invoices-pdf', async (req, res) => {
  try {
    const { venueId, orderId, storagePath } = req.body || {};
    if (!venueId || !orderId || !storagePath) {
      return res.status(400).json({ ok:false, error:"missing venueId/orderId/storagePath" });
    }

    const pdfParseModule = require('pdf-parse');
    const pdfParse =
      (typeof pdfParseModule === 'function')
        ? pdfParseModule
        : (pdfParseModule && (pdfParseModule.default || pdfParseModule.pdfParse || null));
    if (!pdfParse) return res.status(500).json({ ok:false, error: 'pdf-parse module did not resolve to a function' });

    const bucket = admin.storage().bucket();
    const file = bucket.file(storagePath);
    const [buf] = await file.download({ validation: false });
    if (!buf || !buf.length) return res.status(400).json({ ok:false, error: 'Empty PDF buffer' });

    const parsed = await pdfParse(buf).catch(err => {
      throw new Error('PDF parse failed: ' + (err?.message || err));
    });
    const text = String(parsed?.text || '');

    const poMatch = text.match(/\b(P(?:urchase)?\.?\s*O(?:rder)?)\s*(?:No\.?|#|:)?\s*([A-Za-z0-9\-\/]+)\b/i);
    const poNumber = poMatch ? poMatch[2] : null;

    const { lines, warnings } = extractPdfLines(text);
    const confidence =
      (lines.length >= 3 && lines.some(x => x.unitPrice && x.unitPrice > 0)) ? 0.8
      : (lines.length >= 1 ? 0.6 : 0.4);

    return res.json({
      ok:true,
      invoice: { source: 'pdf', storagePath, poNumber },
      lines,
      matchReport: { warnings: warnings.length ? warnings : undefined },
      confidence,
      warnings
    });
  } catch (e) {
    console.error('[api/process-invoices-pdf] error', e);
    return res.status(500).json({ ok:false, error: String(e?.message || e) });
  }
});

// ------------------------- CSV processor ------------------------
function _normHeader(s) {
  return String(s || '').toLowerCase().trim().replace(/[\s\-_]+/g, '');
}
function _toNumber(v) {
  if (v == null) return undefined;
  const s = String(v).replace(/[,\s]/g, '');
  const n = Number(s);
  return Number.isFinite(n) ? n : undefined;
}

app.post(['/process-invoices-csv','/api/process-invoices-csv'], async (req, res) => {
  try {
    const { venueId, orderId, storagePath } = req.body || {};
    if (!venueId || !orderId || !storagePath) {
      return res.status(400).json({ ok:false, error:"missing venueId/orderId/storagePath" });
    }
    const bucket = admin.storage().bucket();
    const file = bucket.file(storagePath);
    const [buf] = await file.download({ validation: false });
    const text = buf.toString('utf8');

    const rows = csvParseSync(text, {
      columns: true,
      bom: true,
      skip_empty_lines: true,
      relax_column_count: true,
      trim: true
    });

    if (!rows.length) {
      return res.json({ ok:true, invoice:{ source:'csv', storagePath }, lines:[], matchReport:null, confidence:0.2, warnings:['CSV contained no data rows.'] });
    }

    // Build header map: normalized header -> original key
    const first = rows[0];
    const headerMap = {};
    Object.keys(first).forEach(k => { headerMap[_normHeader(k)] = k; });

    const H = (want) => headerMap[want];
    const codeKey = H('code') || H('sku') || H('productcode') || H('itemcode');
    const nameKey = H('name') || H('description') || H('item') || H('product');
    const qtyKey  = H('qty') || H('quantity') || H('receivedqty') || H('units') || H('received');
    const unitKey = H('unitprice') || H('price') || H('costprice') || H('cost') || H('unitcost');

    const warnings = [];
    const missing = [];
    if (!nameKey && !codeKey) missing.push('name/code');
    if (!qtyKey) missing.push('qty');
    if (!unitKey) warnings.push('No unit price column detected; unitPrice set to 0 by default.');

    if (missing.length) {
      return res.json({
        ok:true,
        invoice:{ source:'csv', storagePath },
        lines:[],
        matchReport:{ warnings:[`Missing required columns: ${missing.join(', ')}`] },
        confidence:0.2,
        warnings:[`Missing required columns: ${missing.join(', ')}`]
      });
    }

    const lines = [];
    for (const r of rows) {
      const code = codeKey ? String(r[codeKey] ?? '').trim() : undefined;
      const name = nameKey ? String(r[nameKey] ?? '').trim() : (code || '');
      const qty  = _toNumber(qtyKey ? r[qtyKey] : undefined) ?? 0;
      const unit = _toNumber(unitKey ? r[unitKey] : undefined) ?? 0;
      if (!name && !code && qty === 0 && unit === 0) continue;
      lines.push({ code: code || undefined, name: name || '(item)', qty, unitPrice: unit });
    }

    const headerScore =
      (nameKey ? 0.35 : 0) +
      (qtyKey ? 0.35 : 0) +
      (unitKey ? 0.20 : 0) +
      (codeKey ? 0.10 : 0);
    const volumeScore = Math.min(lines.length / 50, 0.25);
    const confidence = Math.max(0.4, Math.min(0.95, headerScore + volumeScore));

    return res.json({
      ok:true,
      invoice: { source:'csv', storagePath },
      lines,
      matchReport: { warnings: warnings.length ? warnings : undefined },
      confidence,
      warnings
    });
  } catch (e) {
    console.error('[process-invoices-csv] error', e);
    return res.status(500).json({ ok:false, error: String(e?.message || e) });
  }
});

// ----------------------- Reconcile (NEW) ------------------------
function toKey(x) {
  if (!x) return '';
  return String(x).toLowerCase().replace(/\s+/g,'').replace(/[^a-z0-9]/g,'');
}
function priceEq(a,b,tol=0.009) {
  if (!Number.isFinite(a) || !Number.isFinite(b)) return false;
  return Math.abs(a-b) <= tol;
}
app.post('/api/reconcile-invoice', async (req, res) => {
  try {
    const { venueId, orderId, invoice, lines } = req.body || {};
    if (!venueId || !orderId || !invoice || !Array.isArray(lines)) {
      return res.status(400).json({ ok:false, error:"missing venueId/orderId/invoice/lines" });
    }

    const db = admin.firestore();
    const orderRef = db.doc(`venues/${venueId}/orders/${orderId}`);
    const orderSnap = await orderRef.get();
    if (!orderSnap.exists) return res.status(404).json({ ok:false, error:'order_not_found' });
    const order = orderSnap.data() || {};

    const poMatch = !!(String(order.poNumber||'').trim() && String(invoice.poNumber||'').trim() && String(order.poNumber).trim() === String(invoice.poNumber).trim());

    // read order lines
    const linesSnap = await db.collection(`venues/${venueId}/orders/${orderId}/lines`).get();
    const ordered = [];
    linesSnap.forEach(doc => {
      const d = doc.data()||{};
      ordered.push({
        id: doc.id,
        code: d.code || d.sku || undefined,
        name: d.name || '',
        qty: Number(d.qty||0),
        unitCost: Number(d.unitCost||0),
        productId: d.productId || null,
      });
    });

    // index order by code/name keys
    const byCode = new Map();
    const byName = new Map();
    for (const ol of ordered) {
      if (ol.code) byCode.set(toKey(ol.code), ol);
      if (ol.name) byName.set(toKey(ol.name), ol);
    }

    const matched = [];
    const unknown_items = [];
    const price_changes = [];
    const qty_diffs = [];

    for (const il of (lines||[])) {
      const keyC = toKey(il.code);
      const keyN = toKey(il.name);
      const found = (keyC && byCode.get(keyC)) || (keyN && byName.get(keyN)) || null;
      if (!found) {
        unknown_items.push({ code: il.code||null, name: il.name||null, qty: Number(il.qty||0), unitPrice: Number(il.unitPrice||0) });
        continue;
      }
      // compare price & qty
      const priceChanged = Number.isFinite(il.unitPrice) && !priceEq(Number(il.unitPrice), Number(found.unitCost));
      const qtyDiff = Number(il.qty||0) - Number(found.qty||0);

      matched.push({ productId: found.productId||null, orderName: found.name, invoiceName: il.name, orderQty: found.qty, invoiceQty: Number(il.qty||0), orderUnit: found.unitCost, invoiceUnit: Number(il.unitPrice||0) });

      if (priceChanged) {
        price_changes.push({
          productId: found.productId||null,
          from: Number(found.unitCost||0),
          to: Number(il.unitPrice||0),
          delta: Number(il.unitPrice||0) - Number(found.unitCost||0),
          name: found.name
        });
      }
      if (Math.abs(qtyDiff) > 0.0001) {
        qty_diffs.push({
          productId: found.productId||null,
          name: found.name,
          ordered: Number(found.qty||0),
          invoiced: Number(il.qty||0),
          delta: qtyDiff
        });
      }
    }

    // items on order but not on invoice
    const missing_on_invoice = [];
    const invKeySet = new Set((lines||[]).map(x => toKey(x.code)||toKey(x.name)));
    for (const ol of ordered) {
      const k = toKey(ol.code)||toKey(ol.name);
      if (!invKeySet.has(k)) {
        missing_on_invoice.push({
          productId: ol.productId||null, name: ol.name, ordered: Number(ol.qty||0), unitCost: Number(ol.unitCost||0)
        });
      }
    }

    const totalOrdered = ordered.reduce((s,o)=>s + Number(o.qty||0)*Number(o.unitCost||0), 0);
    const totalInvoiced = (lines||[]).reduce((s,i)=>s + Number(i.qty||0)*Number(i.unitPrice||0), 0);
    const valueDelta = totalInvoiced - totalOrdered;

    const summary = {
      poMatch,
      counts: {
        matched: matched.length,
        unknown: unknown_items.length,
        priceChanges: price_changes.length,
        qtyDiffs: qty_diffs.length,
        missingOnInvoice: missing_on_invoice.length,
      },
      totals: {
        ordered: Number(totalOrdered.toFixed(2)),
        invoiced: Number(totalInvoiced.toFixed(2)),
        delta: Number(valueDelta.toFixed(2)),
      }
    };

    const recRef = db.collection(`venues/${venueId}/orders/${orderId}/reconciliations`).doc();
    await recRef.set({
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      source: invoice?.source || null,
      storagePath: invoice?.storagePath || null,
      poNumber: invoice?.poNumber ?? null,
      poMatch,
      confidence: Number.isFinite(Number(invoice?.confidence)) ? Number(invoice.confidence) : null,
      warnings: Array.isArray(invoice?.warnings) ? invoice.warnings.slice(0, 20) : [],
      diffs: {
        matched,
        unknown_items,
        price_changes,
        qty_diffs,
        missing_on_invoice,
      },
      summary
    }, { merge: true });

    return res.json({ ok:true, reconciliationId: recRef.id, summary });
  } catch (e) {
    console.error('[api/reconcile-invoice] error', e);
    return res.status(500).json({ ok:false, error: String(e?.message || e) });
  }
});

// Export one Express function (all routes)
exports.api = functions.region('us-central1').runWith({ memory: '512MB', timeoutSeconds: 120 }).https.onRequest(app);
